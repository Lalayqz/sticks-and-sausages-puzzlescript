author Lala_yqz

sprite_size 10x10
run_rules_on_level_start

verbose_logging
debug
//


====
TAGS
====

pushable_type = stick sausage
is_tip_or_packed = tip_or_packed not_tip_or_packed

fixed_type = ground grill
floor = floor_0 floor_1 floor_2
low_floor = floor_0 floor_1
high_floor = floor_1 floor_2
floor_x = floor

force_type = simple slip insert
force_type_simple_or_slip = simple slip
is_countered = uncountered countered

which_space = this_space next_space

pushable_type_2 = pushable_type
is_tip_or_packed_2 = is_tip_or_packed
directions_2 = directions
force_type_2 = force_type

again_round_type = grill fall pack

========
MAPPINGS
========

directions => opposite_direction
up down left right -> down up right left

directions => clockwise_direction
up right down left -> right down left up

directions => counter_clockwise_direction
up right down left -> left up right down

pushable_type => opposite_pushable_type
stick sausage -> sausage stick

low_floor => higher_floor
floor_0 floor_1 -> floor_1 floor_2

high_floor => lower_floor
floor_1 floor_2 -> floor_0 floor_1


========
OBJECTS
========

( [Force Legend]
stick_simple              \            stick_insert
sausage_simple sausage_slip  sausage_insert )

background 
black     

fixed:ground:floor_0
#C6743D #AF6736 #63381D #422513 #211209
1000000001
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
1000000001
2222222222
2222222222
2222222222
3333333333
4444444444

fixed:ground:floor_1
#12A52D #0F8E27 #0D7A21 #63381D
1000000001
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
1000000001
2222222222
2222222222
3333333333
3333333333
3333333333
translate: up:5

fixed:ground:floor_2
brown brown #63381D #63381D
copy: fixed:ground:floor_1 translate: up:5

fixed:grill:floor_0
#252525 orange red black #63381D
2200220011
2200220011
0000000000
0000000000
1100220022
1100220022
0000000000
0000000000
1100110022
1100110022
3333333333
3333333333
4444444444
4444444444
4444444444

fixed:grill:floor_1
#252525 orange red black #63381D
copy: fixed:grill:floor_0 translate: up:5

fixed:grill:floor_2
#252525 orange red black #63381D
copy: fixed:grill:floor_1 translate: up:5

pushable:pushable_type:is_tip_or_packed:directions:floor
transparent

pushable:stick:tip_or_packed:up:floor_0
orange brown
..........
..........
...0......
...00.....
...000....
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...1111...
...1111...
..........

pushable:stick:not_tip_or_packed:down:floor_0
orange brown
..........
..........
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...0000...
...1111...
...1111...
..........

pushable:stick:is_tip_or_packed:directions:floor_1
orange brown
copy: pushable:stick:is_tip_or_packed:directions:floor_0 translate: up:5

pushable:stick:is_tip_or_packed:directions:floor_2
orange brown
copy: pushable:stick:is_tip_or_packed:directions:floor_1 translate: up:5

_stick_bottom:floor_0
orange brown
..........
..........
..........
..........
..........
..........
..........
..........
..........
...0000...
...1111...
...1111...
..........

_stick_bottom:floor_1
orange brown
copy: _stick_bottom:floor_0 translate: up:5

_stick_bottom:floor_2
orange brown
copy: _stick_bottom:floor_1 translate: up:5


pushable:sausage:not_tip_or_packed:up:floor_0
#e06f8b #cc6680 #994d60
..........
..........
..000000..
..000000..
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
1111111111
1111111111
1111111111

pushable:sausage:not_tip_or_packed:down:floor_0
#e06f8b #cc6680 #994d60
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
1100000011
1100000011
.11111111.
..111111..
...1111...
..........
..........

pushable:sausage:not_tip_or_packed:left:floor_0
#e06f8b #cc6680 #994d60
..........
..........
..00000000
.000000000
.000000000
0000000000
0000000000
0000000000
0000000000
1000000000
2111111111
2211111111
.222222222
..22222222
..........


pushable:sausage:not_tip_or_packed:right:floor_0
#e06f8b #cc6680 #994d60
..........
..........
00000000..
000000000.
000000000.
0000000000
0000000000
0000000000
0000000000
0000000001
1111111111
1111111122
222222222.
22222222..
..........

pushable:sausage:is_tip_or_packed:directions:floor_1
#e06f8b #cc6680 #994d60
copy: pushable:sausage:is_tip_or_packed:directions:floor_0 translate: up:5

pushable:sausage:is_tip_or_packed:directions:floor_2
#e06f8b #cc6680 #994d60
copy: pushable:sausage:is_tip_or_packed:directions:floor_1 translate: up:5

goal:floor
transparent

goal_border:directions:floor_0
yellow
0000000000
..........
..........
..........
..........
..........
..........
..........
..........
..........
rot: up:> translate: up:5

goal_border:directions:floor_1
yellow
copy: goal_border:directions:floor_0 translate: up:5

goal_border:directions:floor_2
yellow
copy: goal_border:directions:floor_1 translate: up:5


_force:force_type:directions:pushable_type:floor:is_countered
transparent

_force:simple:directions:stick:floor_0:uncountered
black
..0..
.000.
0.0.0
..0..
..0..
rot: up:> translate: up:10

_force:simple:directions:stick:floor_1:uncountered
black
copy: _force:simple:directions:stick:floor_0:uncountered translate: up:5

_force:simple:directions:stick:floor_2:uncountered
black
copy: _force:simple:directions:stick:floor_1:uncountered translate: up:5

_force:insert:directions:stick:floor_0:uncountered
red
..0..
.000.
0.0.0
..0..
..0..
rot: up:> translate: up:10 translate: right:5

_force:insert:directions:stick:floor_1:uncountered
red
copy: _force:insert:directions:stick:floor_0:uncountered translate: up:5

_force:insert:directions:stick:floor_2:uncountered
red
copy: _force:insert:directions:stick:floor_1:uncountered translate: up:5

_force:simple:directions:sausage:floor_0:uncountered
black
..0..
.000.
0.0.0
..0..
..0..
rot: up:> translate: up:5

_force:simple:directions:sausage:floor_1:uncountered
black
copy: _force:simple:directions:sausage:floor_0:uncountered translate: up:5

_force:simple:directions:sausage:floor_2:uncountered
black
copy: _force:simple:directions:sausage:floor_1:uncountered translate: up:5

_force:slip:directions:sausage:floor_0:uncountered
blue
..0..
.000.
0.0.0
..0..
..0..
rot: up:> translate: up:5 translate: right:2

_force:slip:directions:sausage:floor_1:uncountered
blue
copy: _force:slip:directions:sausage:floor_0:uncountered translate: up:5

_force:slip:directions:sausage:floor_2:uncountered
blue
copy: _force:slip:directions:sausage:floor_1:uncountered translate: up:5

_force:insert:directions:sausage:floor_0:uncountered
red
..0..
.000.
0.0.0
..0..
..0..
rot: up:> translate: up:5 translate: right:5

_force:insert:directions:sausage:floor_1:uncountered
red
copy: _force:insert:directions:sausage:floor_0:uncountered translate: up:5

_force:insert:directions:sausage:floor_2:uncountered
red
copy: _force:insert:directions:sausage:floor_1:uncountered translate: up:5

_force:simple:directions:stick:floor:countered
grey
copy: _force:simple:directions:stick:floor:uncountered

_force:insert:directions:stick:floor:countered
orange
copy: _force:insert:directions:stick:floor:uncountered

_force:simple:directions:sausage:floor:countered
grey
copy: _force:simple:directions:sausage:floor:uncountered

_force:slip:directions:sausage:floor:countered
lightblue
copy: _force:slip:directions:sausage:floor:uncountered

_force:insert:directions:sausage:floor:countered
orange
copy: _force:insert:directions:sausage:floor:uncountered


_temp_force_direction:force_type:directions:pushable_type:floor
transparent

_spread:pushable_type:floor
transparent

_spread_next:pushable_type:floor
transparent

_calculate_moving_direction:pushable_type:floor
transparent

_old_moving_direction:pushable_type:floor:directions
transparent

( pierce & through_hole mark the objects to bypass the blocking process )
_pierce:pushable_type:floor:directions (pierce means piercing through NEXT SPACE)
transparent

_through_hole:pushable_type:floor:directions:which_space
transparent

_input:directions
transparent

_insert_force_source:pushable_type:floor
transparent

_top_left_spot
transparent

_can_fall_again
transparent

_do_again:again_round_type
transparent

_supported:floor
transparent

_just_fell:floor
transparent

_not_on_goal:floor
transparent

=======
LEGEND
=======

thing = pushable:pushable_type:is_tip_or_packed:directions:floor or fixed:fixed_type:floor

O = background
_ = fixed:ground:floor_0
. = fixed:ground:floor_0 and fixed:ground:floor_1
0 = fixed:ground:floor_0 and fixed:ground:floor_1 and fixed:ground:floor_2
# = fixed:ground:floor_0 and fixed:grill:floor_1

X = fixed:ground:floor_0 and fixed:ground:floor_1 and goal:floor_1

∩ = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:sausage:not_tip_or_packed:up:floor_2
U = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:sausage:not_tip_or_packed:down:floor_2
{ = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:sausage:not_tip_or_packed:left:floor_2
} = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:sausage:not_tip_or_packed:right:floor_2
t = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:stick:tip_or_packed:up:floor_2
b = fixed:ground:floor_0 and fixed:ground:floor_1 and pushable:stick:not_tip_or_packed:down:floor_2

% = _top_left_spot

player = pushable:stick:is_tip_or_packed:directions:floor

================
COLLISIONLAYERS
================

background
floor -> fixed:fixed_type:floor
goal:floor
directions floor -> goal_border:directions:floor

pushable:stick:is_tip_or_packed:directions:floor_0
pushable:sausage:is_tip_or_packed:directions:floor_0
_stick_bottom:floor_0
pushable:stick:is_tip_or_packed:directions:floor_1
pushable:sausage:is_tip_or_packed:directions:floor_1
_stick_bottom:floor_1
pushable:stick:is_tip_or_packed:directions:floor_2
pushable:sausage:is_tip_or_packed:directions:floor_2
_stick_bottom:floor_2

force_type directions pushable_type floor -> _force:force_type:directions:pushable_type:floor:is_countered
force_type pushable_type floor -> _temp_force_direction:force_type:directions:pushable_type:floor

pushable_type floor -> _spread:pushable_type:floor, _spread_next:pushable_type:floor
pushable_type floor -> _calculate_moving_direction:pushable_type:floor

_insert_force_source:pushable_type:floor
pushable_type floor -> _old_moving_direction:pushable_type:floor:directions
_pierce:pushable_type:floor:directions
pushable_type directions which_space -> _through_hole:pushable_type:floor:directions:which_space
_input:directions

_top_left_spot
_can_fall_again
again_round_type -> _do_again:again_round_type
floor -> _supported:floor
floor -> _just_fell:floor
floor -> _not_on_goal:floor

======
SOUNDS
======

sfx0 81019907 ( Fall onto ground )
sfx1 81700105 ( Fall into void )
sfx2 80064702 ( Grill )

=====
RULES     
=====

// I'm putting late rules here because of issue #145.
( Remove temp stuff )
( - Remove input )
late [_input:directions] -> []
( - Remove forces )
late [_force:force_type:directions:pushable_type:floor:is_countered] -> []
late [_temp_force_direction:force_type:directions:pushable_type:floor] -> []
( - Remove insert_force_source )
late [_insert_force_source:pushable_type:floor] -> []
( - Remove pierce & through_hole )
late [_pierce:pushable_type:floor:directions] -> []
late [_through_hole:pushable_type:floor:directions:which_space] -> []


( Do grill & check if can grill )
  ( - Do grill )
  late low_floor [fixed:grill:low_floor pushable:stick:tip_or_packed:directions:higher_floor no pushable:sausage:not_tip_or_packed:directions:higher_floor] [_do_again:grill] -> [fixed:grill:low_floor] [_do_again:grill] sfx2
  late [_do_again:grill] -> []
  ( - Check if can grill )
  late low_floor [fixed:grill:low_floor pushable:stick:tip_or_packed:directions:higher_floor no pushable:sausage:not_tip_or_packed:directions:higher_floor] -> [fixed:grill:low_floor pushable:stick:tip_or_packed:directions:higher_floor _do_again:grill] again


( Fall related stuff )
// There could be multiple falls.
// If the first fall is valid, then fires another process turn. But later valid falls don't fire that.
// This difference means that I have to take the logic of the first fall out of the fall loop.
startloop
  ( Calculate supported:floor )
    ( - Supported by fixed below )
    late low_floor [fixed:fixed_type:low_floor pushable:pushable_type:is_tip_or_packed:directions:higher_floor] -> [fixed:fixed_type:low_floor pushable:pushable_type:is_tip_or_packed:directions:higher_floor _supported:higher_floor]
    ( - Supported by supported below )
    // There is no "supported by insert" because they share the same supported:floor.
    + late low_floor [_supported:low_floor pushable:pushable_type:is_tip_or_packed:directions:higher_floor] -> [_supported:low_floor pushable:pushable_type:is_tip_or_packed:directions:higher_floor _supported:higher_floor]
    ( - Spread supported )
    + late pushable_type floor [pushable:pushable_type:is_tip_or_packed:<:floor _supported:floor | pushable:pushable_type:is_tip_or_packed:>:floor] -> [pushable:pushable_type:is_tip_or_packed:<:floor _supported:floor | pushable:pushable_type:is_tip_or_packed:>:floor _supported:floor]
  ( Do fall )
    ( - Fall into void below )
    late [pushable:pushable_type:is_tip_or_packed:directions:floor_0] [_do_again:fall] -> [] [_do_again:fall] sfx1
    ( - Fall into space below )
    // When 2 objects are on top of each other, make the bottom one fall first. So no pushable:...:lower_floor.
    // After something falls, add a _just_fell to that target space so it won't fall again.
    late pushable_type is_tip_or_packed directions high_floor [pushable:pushable_type:is_tip_or_packed:directions:high_floor no _supported:floor no _just_fell:floor no pushable:pushable_type_2:is_tip_or_packed_2:directions_2:lower_floor] [_do_again:fall] -> [pushable:pushable_type:is_tip_or_packed:directions:lower_floor _just_fell:lower_floor] [_do_again:fall]
    late [_just_fell:floor] -> []
  ( Check if can fall )
    ( - Fall into space below )
    late pushable_type is_tip_or_packed directions high_floor [pushable:pushable_type:is_tip_or_packed:directions:high_floor no _supported:floor] -> [pushable:pushable_type:is_tip_or_packed:directions:high_floor _can_fall_again]
    ( - Fall into void below )
    late [pushable:pushable_type:is_tip_or_packed:directions:floor_0] -> [pushable:pushable_type:is_tip_or_packed:directions:floor_0 _can_fall_again]
endloop
( Clear _supported )
late [_supported:floor] -> []
( _can_again -> _do_again )
late [_can_fall_again] -> [_do_again:fall] again


( Do pack & check if can pack )
  ( - Calculate _not_on_goal )
  late floor [pushable:sausage:not_tip_or_packed:directions:floor no goal:floor_x] -> [pushable:sausage:not_tip_or_packed:directions:floor _not_on_goal:floor]
  late floor [pushable:sausage:not_tip_or_packed:<:floor _not_on_goal:floor | pushable:sausage:not_tip_or_packed:>:floor] -> [pushable:sausage:not_tip_or_packed:<:floor _not_on_goal:floor | pushable:sausage:not_tip_or_packed:>:floor _not_on_goal:floor]
  ( - Do pack )
  late directions floor [pushable:sausage:not_tip_or_packed:directions:floor no _not_on_goal:floor] [_do_again:pack] -> [pushable:sausage:tip_or_packed:directions:floor] [_do_again:pack]
  late [_do_again:pack] -> []
  ( - Check if can pack )  // Add _can_again:pack to top left spot
  late floor [pushable:sausage:not_tip_or_packed:directions:floor no _not_on_goal:floor] [_top_left_spot] -> [pushable:sausage:not_tip_or_packed:directions:floor] [_top_left_spot _do_again:pack] again
  ( - Clear _not_on_goal )
  late [_not_on_goal:floor] -> []


( Add temp sprites )
late floor [pushable:stick:tip_or_packed:up:floor] -> [pushable:stick:tip_or_packed:up:floor _stick_bottom:floor]
late floor [pushable:stick:not_tip_or_packed:down:floor] -> [pushable:stick:not_tip_or_packed:down:floor _stick_bottom:floor]




( Clear temp sprites )
[_stick_bottom:floor] -> []

( Calculate goal borders )
floor [goal:floor | no goal:floor_x ] -> [goal:floor goal_border:>:floor | goal_border:<:floor]


( Save input direction on player and give force )
floor [> pushable:stick:is_tip_or_packed:directions:floor] -> [> pushable:stick:is_tip_or_packed:directions:floor _input:> _force:insert:>:stick:floor:uncountered]
( Calculate pierce )
floor [> pushable:stick:tip_or_packed:>:floor | pushable:sausage:not_tip_or_packed:directions:floor] -> [> pushable:stick:tip_or_packed:>:floor _pierce:stick:floor:> | pushable:sausage:not_tip_or_packed:directions:floor]
( Calculate through_hole )
  ( - Calculate through_hole:...:this_space )
floor [pushable:stick:is_tip_or_packed:>:floor pushable:sausage:not_tip_or_packed:directions:floor] -> [pushable:stick:is_tip_or_packed:>:floor pushable:sausage:not_tip_or_packed:directions:floor _through_hole:stick:floor:>:this_space _through_hole:stick:floor:<:this_space _through_hole:sausage:floor:>:this_space _through_hole:sausage:floor:<:this_space]
  ( - Calculate through_hole:...:next_space )
floor [pushable:stick:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:directions:floor] -> [pushable:stick:is_tip_or_packed:<:floor _through_hole:stick:floor:>:next_space | pushable:sausage:not_tip_or_packed:directions:floor _through_hole:sausage:floor:<:next_space]


startloop
  ( Give force to player ) // When subroutine remove_force_from_old_moving_direction removed the force .
  floor [_input:> pushable:stick:is_tip_or_packed:directions:floor no _force:insert:>:stick:floor:is_countered] -> [_input:> pushable:stick:is_tip_or_packed:directions:floor _force:insert:>:stick:floor:uncountered _calculate_moving_direction:stick:floor] gosub calculate_moving_direction

  ( I Push )
  
  ( - Insert push )
  // Don't give outgoing force when there is an incoming force between the two?no insert_force_source:pushable_type
  // Calculate moving direction right now, not waiting for other tiles that need calculations and calculate them together. This is because when spreading, 2 tiles wont't spread into each other because they are both spread sources.
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor pushable:opposite_pushable_type:is_tip_or_packed:directions:floor no _force:insert:>:opposite_pushable_type:floor:is_countered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor pushable:opposite_pushable_type:is_tip_or_packed:directions:floor _force:insert:>:opposite_pushable_type:floor:uncountered _insert_force_source:pushable_type:floor _calculate_moving_direction:opposite_pushable_type:floor] gosub calculate_moving_direction
  // [TODO?] If the object you are pushing is moving in the same direction driven by an insert force, then it should not be pushed (because you can't touch it!). This is implemented by adding "no force:insert:>:sausage:uncountered" in the following rules, which is only a makeshift, and only works when there are no multiple objects & no strangely-shaped objects.
  ( - Push opposing sausage )
  pushable_type is_tip_or_packed floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:<:floor no _force:simple:>:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:<:floor _force:simple:>:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
  ( - Push side sausage )
    ( [Rotation A] [Simple + Slip] )
    // The following 2 rules already did this job, but this rule is added to make the rule process shorter
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:^:floor no _force:simple:>:sausage:floor:is_countered no _force:slip:v:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:^:floor _force:simple:>:sausage:floor:uncountered _force:slip:v:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
    ( [Rotation A] [Simple] )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:^:floor no _force:simple:>:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:^:floor _force:simple:>:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
    ( [Rotation A] [Slip] )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:^:floor no _force:slip:v:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:^:floor _force:slip:v:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
    ( [Rotation B] [Simple + Slip] )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:v:floor no _force:simple:>:sausage:floor:is_countered no _force:slip:^:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:v:floor _force:simple:>:sausage:floor:uncountered _force:slip:^:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
    ( [Rotation B] [Simple] )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:v:floor no _force:simple:>:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:v:floor _force:simple:>:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction
    ( [Rotation B] [Slip] )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor no pushable:pushable_type:is_tip_or_packed:<:floor | pushable:sausage:not_tip_or_packed:v:floor no _force:slip:^:sausage:floor:is_countered no _force:insert:>:sausage:floor:uncountered] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor | pushable:sausage:not_tip_or_packed:v:floor _force:slip:^:sausage:floor:uncountered _calculate_moving_direction:sausage:floor] gosub calculate_moving_direction



  ( II Blocked )
  
  ( Blocked by wall )
  force_type pushable_type floor [_force:force_type:>:pushable_type:floor:uncountered > pushable:pushable_type:is_tip_or_packed:directions:floor | fixed:fixed_type:floor] -> [_force:force_type:>:pushable_type:floor:countered > pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor | fixed:fixed_type:floor] gosub calculate_moving_direction
  ( Blocked by another pushable ) // When that another pushable has a countered force of that direction.
    ( - Blocked by same pushable_type in opposing space )
  force_type pushable_type floor [_force:force_type:>:pushable_type:floor:uncountered > pushable:pushable_type:is_tip_or_packed:directions:floor | _force:force_type_2:>:pushable_type:floor:countered] -> [_force:force_type:>:pushable_type:floor:countered > pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor | _force:force_type_2:>:pushable_type:floor:countered] gosub calculate_moving_direction
    ( - Blocked by opposite pushable_type in opposing space ) // Unless current pushable has pierce or through_hole:...:next_space, because these two only apply to opposite pushable_type
    // [TODO] do i really need through_hole???
  pushable_type floor [_force:force_type:>:pushable_type:floor:uncountered > pushable:pushable_type:is_tip_or_packed:directions:floor no _pierce:pushable_type:floor:> no _through_hole:pushable_type:floor:>:next_space | _force:force_type_2:>:opposite_pushable_type:floor:countered] -> [_force:force_type:>:pushable_type:floor:countered > pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor | _force:force_type_2:>:opposite_pushable_type:floor:countered] gosub calculate_moving_direction
    ( - Blocked by a inserted pushable in the same space ) // Unless current pushable has pierce or through_hole:...:this_space
  pushable_type floor [_force:force_type:>:pushable_type:floor:uncountered > pushable:pushable_type:is_tip_or_packed:directions:floor no _through_hole:pushable_type:floor:>:this_space _force:force_type_2:>:opposite_pushable_type:floor:countered] -> [_force:force_type:>:pushable_type:floor:countered > pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor _force:force_type_2:>:opposite_pushable_type:floor:countered] gosub calculate_moving_direction
endloop






subroutine calculate_moving_direction
  ( Save and clear old moving direction )
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor] -> [stationary pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor _old_moving_direction:pushable_type:floor:>]
  ( Calculate moving direction for each type of force ) // Using temp_force_direction:force_type:directions.
  // [TODO] add more additional rules
  force_type directions pushable_type floor [_force:force_type:directions:pushable_type:floor:uncountered _calculate_moving_direction:pushable_type:floor no _force:force_type:opposite_direction:pushable_type:floor:uncountered no _force:force_type:clockwise_direction:pushable_type:floor:uncountered no _force:force_type:counter_clockwise_direction:pushable_type:floor:uncountered] -> [_temp_force_direction:force_type:directions:pushable_type:floor _force:force_type:directions:pushable_type:floor:uncountered _calculate_moving_direction:pushable_type:floor]
  ( Calculate final moving direction, using insert push )
  pushable_type floor [pushable:pushable_type:is_tip_or_packed:directions:floor _temp_force_direction:insert:>:pushable_type:floor _calculate_moving_direction:pushable_type:floor] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor _temp_force_direction:insert:>:pushable_type:floor _calculate_moving_direction:pushable_type:floor _spread:pushable_type:floor]
  ( Calculate final moving direction, using slip push )
  pushable_type floor [pushable:pushable_type:is_tip_or_packed:directions:floor _temp_force_direction:slip:>:pushable_type:floor _calculate_moving_direction:pushable_type:floor no _temp_force_direction:insert:directions:pushable_type:floor] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor _temp_force_direction:slip:>:pushable_type:floor _calculate_moving_direction:pushable_type:floor _spread:pushable_type:floor]
  ( Calculate final moving direction, using simple push)
  pushable_type floor [pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor _temp_force_direction:simple:>:pushable_type:floor no _temp_force_direction:insert:directions:pushable_type:floor no _temp_force_direction:slip:directions:pushable_type:floor] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor _temp_force_direction:simple:>:pushable_type:floor _spread:pushable_type:floor]
  
  ( Clear old_moving_direction ) // If new direction is the same as it.
  pushable_type floor [> pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor _old_moving_direction:pushable_type:floor:>] -> [> pushable:pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type:floor]
  ( Clear "temp_force_direction:force_type" & "calculate_moving_direction", add "spread" )
  [_temp_force_direction:force_type:directions:pushable_type:floor] -> []
  pushable_type floor [_calculate_moving_direction:pushable_type:floor] -> [_spread:pushable_type:floor] gosub spread



( Spread moving direction & force within rigid )
subroutine spread
  startloop
    ( Spread moving )
    pushable_type floor [orthogonal pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor no _spread:pushable_type:floor] -> [orthogonal pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | orthogonal pushable:pushable_type:is_tip_or_packed:>:floor _spread_next:pushable_type:floor]
    ( Spread not moving )
    pushable_type floor [stationary pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor no _spread:pushable_type:floor] -> [stationary pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | stationary pushable:pushable_type:is_tip_or_packed:>:floor _spread_next:pushable_type:floor]
    ( Spread force )
    // [BUG?] switching the last two objects breaks the rule, when there is a tag as a rule prefix
    force_type directions pushable_type is_countered floor  [_force:force_type:directions:pushable_type:floor:is_countered pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor no _spread:pushable_type:floor] -> [_force:force_type:directions:pushable_type:floor:is_countered pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor _force:force_type:directions:pushable_type:floor:is_countered _spread_next:pushable_type:floor]
    ( Spread no force )
    force_type directions pushable_type is_countered floor [pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor no _force:force_type:directions:pushable_type:floor:is_countered | pushable:pushable_type:is_tip_or_packed:>:floor no _spread:pushable_type:floor] -> [pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor no _force:force_type:directions:pushable_type:floor:is_countered _spread_next:pushable_type:floor]
    ( Spread old_moving_direction )
    directions pushable_type floor [_old_moving_direction:pushable_type:floor:directions pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor no _spread:pushable_type:floor] -> [_old_moving_direction:pushable_type:floor:directions pushable:pushable_type:is_tip_or_packed:<:floor _spread:pushable_type:floor | pushable:pushable_type:is_tip_or_packed:>:floor _old_moving_direction:pushable_type:floor:directions _spread_next:pushable_type:floor]
    
    pushable_type floor [_spread_next:pushable_type:floor] -> [_spread:pushable_type:floor]
  endloop
  [_spread:pushable_type:floor] -> []
  
  ( Remove force from pushables in the old moving direction )
  [_old_moving_direction:pushable_type:floor:directions] -> [_old_moving_direction:pushable_type:floor:directions] gosub remove_force_from_old_moving_direction
  

// How to deal with blocked objects:
// In reality, forces are a result of two objects constantly squeezing into each other. When an object is blocked, due to the order of their positions (there is an position order of the squeezed side even if they are all inserted into each other), the object in source direction is blocked, and the object in destination direction is no longer squeezed.
// So the most realistic way to implement the rule is making a tiny squeeze from the player each loop and then spread the squeeze, while the object blocked last loop are still blocked and the squeezes last loop won't be carried to next loop.
// But does it work? Refer to the 3rd case in edge_cases.png (not public).
// This game uses another "self-correcting" way to implement the rule.
subroutine remove_force_from_old_moving_direction
  ( Remove outgoing "insert" force )
  pushable_type floor [_old_moving_direction:pushable_type:floor:> pushable:opposite_pushable_type:is_tip_or_packed:directions:floor _force:insert:>:opposite_pushable_type:floor:is_countered _insert_force_source:pushable_type:floor] -> [_old_moving_direction:pushable_type:floor:> stationary pushable:opposite_pushable_type:is_tip_or_packed:directions:floor _calculate_moving_direction:opposite_pushable_type:floor] gosub calculate_moving_direction
  ( Remove all simple/slip force from facing tile in old moving direction )
  pushable_type_2 floor [_old_moving_direction:pushable_type:floor:> | pushable:pushable_type_2:is_tip_or_packed:directions:floor _force:force_type_simple_or_slip:directions:pushable_type_2:floor:is_countered no _old_moving_direction:pushable_type_2:floor:>] -> [_old_moving_direction:pushable_type:floor:> | stationary pushable:pushable_type_2:is_tip_or_packed:directions:floor _calculate_moving_direction:pushable_type_2:floor] gosub calculate_moving_direction
  [_old_moving_direction:pushable_type:floor:directions] -> []

=======     
LEVELS
=======

section push
level push

%0000000000000
00000000000000
00000000000000
00##....∩...00
00##....U...00
00OO.0{}{}..00
000.....{}{}00
00.0OO..t...00
00..OO..b...00
00.XX.___...00
00.XX.___{}.00
00..{}___.{}00
00000000000000
00000000000000